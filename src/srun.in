#!/bin/bash
#-*- shell-script -*-
#
#  Git Version: @git@
#
#-----------------------------------------------------------------------
# XALT: A tool that tracks users jobs and environments on a cluster.
# Copyright (C) 2013-2014 University of Texas at Austin
# Copyright (C) 2013-2014 University of Tennessee
# 
# This library is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as
# published by the Free Software Foundation; either version 2.1 of 
# the License, or (at your option) any later version. 
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser  General Public License for more details. 
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free
# Software Foundation, Inc., 59 Temple Place, Suite 330,
# Boston, MA 02111-1307 USA
#-----------------------------------------------------------------------

########################################################################
#  If the first argument is --part_of_xalt then exit immediately
#  This avoids problems when there are more than one copy of this
#  command in the path.

if [ "$1" == --part_of_xalt ]; then
  echo "XALT:YES"
  exit
fi

# This srun wrapper only tested on one LANL cluster named mustang.
# Very dependent on the site/xalt_find_exec_srun.py python script.
# Because -n option has no environment variable counterpart, we
# decode it below and pass NTASKS onto xalt_find_exec_srun.
# Also, since srun takes "-n4" and "-n 4" as possibilities, had to
# add logic to decode "-n4" syntax.
# 

MY_PATH=$0
MY_NAME=$(basename $MY_PATH)

XALT_DIR=@xalt_dir@
RUN_SUBMIT=$XALT_DIR/libexec/xalt_run_submission.py
UUIDGEN=@path_to_uuidgen@
WORKING_PYTHON=$XALT_DIR/libexec/xalt_working_python.py
EPOCH=$XALT_DIR/libexec/xalt_epoch.py

FIND_EXEC=$XALT_DIR/site/xalt_find_exec_srun.py

########################################################################
# Search for the command  and make sure that you don't find this one.
# We use "type -p -a" instead of searching the path.  Since bash should
# have search and cached all the executable in the path.  This should be
# faster then walking the path.  But only if this script is treated as a
# bash script.

if [ -n "$BASH_VERSION" ]; then
  for exe in $(type -p -a $MY_NAME); do
    if [ $exe != $MY_PATH ]; then
      MY_CMD=$exe
      break
    fi
  done
else
  ###################################################################
  # If this script is not treated as a bash script then do this the
  # old fashion way.

  OLD_IFS=$IFS
  IFS=:
  for dir in $PATH; do
    if [ $dir/$MY_NAME != $MY_PATH -a -x "$dir/$MY_NAME" ]; then
      MY_CMD="$dir/$MY_NAME"
    fi
  done
  IFS=$OLD_IFS
fi

########################################################################
# Make sure that the python setup is valid.  If a user makes PYTHONHOME
# point to a different python then if stmt will be triggered.

PY_PATH_ORIG=$PYTHONPATH
XALT_DIR=@xalt_dir@
WORKING_PYTHON=$XALT_DIR/libexec/xalt_working_python.py
WORKING=$($MY_PYTHON $WORKING_PYTHON 2> /dev/null)
if [ "$WORKING" != "GOOD" ]; then
  unset PYTHONHOME
  WORKING=$($MY_PYTHON $WORKING_PYTHON 2> /dev/null)
  if [ "$WORKING" != "GOOD" ]; then
    unset PYTHONPATH
    MY_PYTHON=@python@
    WORKING=$($MY_PYTHON $WORKING_PYTHON 2> /dev/null)
    if [ "$WORKING" != "GOOD" ]; then
      echo "XALT: Error in users' python setup.  Please report this error!"
      $MY_CMD "$@"
      exit
    fi
  fi
fi



########################################################################
# Loop over command line arguments to mpirun. This code is used instead of
# getopt and others because this wrapper script should not try to know
# all the options to ld. Instead we are just "cherry-picking" the options
# we want to know about.

append=false
prev=
done=false
for option; do
  if [ -n "$prev" ]; then
    eval "$prev=\$option"
    prev=
    continue
  fi

  case "$option" in
    -*=*) optarg=`builtin echo "$option" | sed  's/[-_a-zA-Z0-9]*=//'` ;;
    -*) optarg=;;
    *) optarg=; done=true;;
  esac

  # this if block just to handle "-n4" option -- the "no space" problem 
  # useful with srun on lanl machine
  str=${option:0:2}
  if [ ${#option} -gt 2 ]; then
    str2=${option:2}
    if [[ $str2 = *[[:digit:]]* ]]; then
    # checks if a string is a number, rejects everything else
      if [[ $str == "-n" ]]; then
        NTASKS=$str2 
      elif [[ $str == "-N" ]]; then
        NNODES=$str2 
      fi
    else
      continue
    fi
  fi
  case $option in
    -n|--ntasks)
      prev='NTASKS'
      ;;
    -N)
      prev='NNODES'
      ;;
    --help|-h|--usage|-V|--version)
      $MY_CMD "$@"
      exit
      ;;
    ---test)
      testMe=true
      ;;
  esac

  #####################################################################
  # This code below is commented out.  Since this script is not parsing
  # all options the done flag won't work.

  #if [ "$done" = "true" ]; then
  #  break;
  #fi
done

  # if NTASKS was not set, try to set it
  #  if NNODES not set then error
  #  else set NTASKS based on various scenarios
  if [[ -z "$NTASKS" ]]; then
    if [[ -z "$NNODES" ]]; then
      echo "XALT srun wrapper error: NTASKS not set"
      exit
    else
      if [[ -z $SLURM_JOBID ]]; then
        # interactive jobs default to one task
        NTASKS=1
      else
        if [[ $NNODES -eq 1 ]]; then
          # one node jobs default to one task
          NTASKS=1
        else
          # multiple node jobs default to corespernode*nodes
          NTASKS=$(($SLURM_CPUS_ON_NODE*$NNODES))
        fi
      fi
    fi
  fi



RUN_UUID=`$UUIDGEN`
DATESTR=`date +%Y_%m_%d_%H_%M_%S`
SYSHOST=$($MY_PYTHON $XALT_DIR/site/xalt_syshost.py)

runFn=$HOME/.xalt.d/run.${SYSHOST}.${DATESTR}.$RUN_UUID.json

EXEC="unknown"
if [ -x "$FIND_EXEC" ]; then
  EXEC=$($MY_PYTHON $FIND_EXEC "$@")
fi

sTime=$($MY_PYTHON $EPOCH)
$MY_PYTHON $RUN_SUBMIT --ntasks $NTASKS --start "$sTime" --end 0        --fn "$runFn" --run_uuid "$RUN_UUID" -- $EXEC

status=0
if [ -z "$testMe" ]; then
  PY_PATH_XALT=$PYTHONPATH
  export PYTHONPATH=$PY_PATH_ORIG
  $MY_CMD "$@"
  status="$?"
  export PYTHONPATH=$PY_PATH_XALT
fi

eTime=$($MY_PYTHON $EPOCH)
$MY_PYTHON $RUN_SUBMIT --ntasks $NTASKS --start "$sTime" --end "$eTime" --fn "$runFn" --run_uuid "$RUN_UUID" -- $EXEC

export PYTHONPATH=$PY_PATH_ORIG
exit $status


